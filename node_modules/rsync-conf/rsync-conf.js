"use strict"
var Q = require('q');
const exec = require('child_process').exec;
var FileSystem = require('fs');

/*
use chroot = false
max connections = 2
log file = /cygdrive/c/ProgramData/TimeMachineVault/rsyncd.log
lock file = /cygdrive/c/ProgramData/TimeMachineVault/rsyncd.lock
[VSSE]
path = /proc/sys/Device/HarddiskVolumeShadowCopy119/\./
read only=true
list = false
exclude = *
include from = /cygdrive/C/ProgramData/TimeMachineVault/include-from-E
*/

var Module = class {
  constructor(name, path) {
    this.Name = name;
    this.Path = path;
    this._List = null;
    this._ReadOnly = null;
    this._IncludeFrom = '';
  }

  set ReadOnly(value) {
    this._ReadOnly = value;
  }
  get ReadOnly() {
    return this._ReadOnly;
  }

  set List(value) {
    this._List = value;
  }
  get ReadOnly() {
    return this._List;
  }

  set IncludeFrom(value) {
    this._IncludeFrom = value;
  }
  get ReadOnly() {
    return this._IncludeFrom;
  }

  toString() {
    let ModuleConf = '';
    ModuleConf += '[' + this.Name + ']\n';
    ModuleConf += '\tpath = ' + this.Path + '\n';
    if (this._ReadOnly) {
      ModuleConf += '\tread only = true\n';
    }
    else {
      ModuleConf += '\tread only = false\n';
    }
    if (this._List) {
      ModuleConf += '\tlist = true\n';
    }
    else {
      ModuleConf += '\tlist = false\n';
    }
    if (this._IncludeFrom.length > 0) {
      ModuleConf += '\tinclude from = ' + this._IncludeFrom + '\n';
    }

    return ModuleConf;
  }
}

function RsyncConf() {
  if (!this) {
    return new RsyncConf();
  }

  this.UseChroot = false;
  this.MaxConnections = 2;
  this.LogFile = '';
  this.LockFile = '';
  this.Modules = [];

  this.AddModule = function(module) {
    //TODO: check for a "Module" object
    this.Modules.push(module);
  }

  this.toString = function() {
    let OutputConf = '';
    if (this.UseChroot) {
      OutputConf += 'use chroot = true\n';
    }
    else {
      OutputConf += 'use chroot = false\n';
    }
    OutputConf += 'max connections = ' + this.MaxConnections + '\n';
    if (this.LogFile.length > 0) {
      OutputConf += 'log file = ' + this.LogFile + '\n';
    }
    if (this.LockFile.length > 0) {
      OutputConf += 'lock file = ' + this.LockFile + '\n';
    }
    OutputConf += '\n';

    for (let module of this.Modules) {
      OutputConf += module.toString();
    }
    return OutputConf;
  }

  this.Save = function (filename, RestartService) {
    let deferred = Q.defer();

    FileSystem.writeFile(filename, this.toString(), function(err) {
      if (err) {
        deferred.reject(err);
      }
      else {
        let ServiceName = "rsyncd";
        if ((typeof RestartService) == "string") {
          ServiceName = RestartService;
          RestartService = true;
        }

        if (RestartService) {
          //TODO: Check to see if the service is running.

          console.log("Stopping " + ServiceName + " service.");
          //TODO: This is Windows specific
          exec("sc stop \"" + ServiceName + "\"", function(error, stdout, stderr) {
            if (error) {
              if (stdout.toString().match(/The service has not been started/i)) {
                console.log("The service was not running.");
              }
              else {
                console.log(stdout, stderr);
                deferred.reject(error);
                return;
              }
            }
            setTimeout(function() {
              console.log("Starting " + ServiceName + " service.");
              exec("sc start \"" + ServiceName + "\"", function(error, stdout, stderr) {
                if (error) {
                  console.log(stdout, stderr);
                  deferred.reject(error);
                }
                else {
                  deferred.resolve();
                }
              });
            }, 5000);
          });
        }
        else {
          deferred.resolve();
        }
      }
    })

    return deferred.promise;
  }
}

module.exports = new RsyncConf();
module.exports.Module = Module;
