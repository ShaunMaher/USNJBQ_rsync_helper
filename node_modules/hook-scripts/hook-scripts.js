"use strict"
var Q = require('q');
var FileSystem = require('fs');
var Path = require('path');
const exec = require('child_process').exec;

function HookScripts() {
  if (!this) {
    return new HookScripts();
  }

  let ScriptName = require.main.filename;
  let ScriptExt = Path.extname(ScriptName);
  let ScriptDir = Path.dirname(ScriptName);
  ScriptName = Path.basename(ScriptName, ScriptExt);

  // Filesystem Root
  let FSRoot = Path.dirname(require.main.filename);
  while (Path.dirname(FSRoot) != FSRoot) {
    FSRoot = Path.dirname(FSRoot);
  }

  // This is a big list of places we should look for hook scripts if the calling
  //  app doesn't specify any.
  this.SearchPaths = [
    ScriptDir,
    Path.dirname(ScriptDir),
    Path.dirname(Path.dirname(ScriptDir)),
    ScriptDir + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "hooks",
    ScriptDir + Path.sep + "etc" + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "etc" + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "etc" + Path.sep + "hooks",
    FSRoot + Path.sep + "etc" + Path.sep + "hooks",
    ScriptDir + Path.sep + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    FSRoot + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
  ];

  this.RunScripts = function(EventName) {
    let deferred = Q.defer();
    let Scripts = [];

    var ReaddirPromises = [];
    for (var searchpath of this.SearchPaths) {
      ReaddirPromises.push((function(path) {
        let ReaddirDeferred = Q.defer();
        FileSystem.stat(path, function(err, stats) {
          if (err) {
            // The directory not existing isn't fatal.  There might be other
            //  directories that exist.
            ReaddirDeferred.resolve(false);
            return false;
          }

          FileSystem.readdir(path, function(err, files) {
            if (err) {
              console.log(path + ": " + err.message);
              ReaddirDeferred.reject(err);
              return false;
            }

            for (let Script of files) {
              let ScriptEventName = (Script.split(/\./))[0];
              if (ScriptEventName.toLowerCase() == EventName.toLowerCase()) {
                Scripts.push(path + Path.sep + Script);
              }
            }
            ReaddirDeferred.resolve(true);
          });
        });
        return ReaddirDeferred.promise;
      }).call(this, searchpath));
    }

    Q.allSettled(ReaddirPromises).then(function(items) {
      console.log(EventName + " hooks: ", Scripts);

      // Script file names should be in the format of EventName[.priority].Name
      //  for example: "pre-snapshot.01.SayHelloEarly.cmd" or
      //  "pre-snapshot.SayHello.cmd".  The numerical priority should be two
      //  digits so use a leading zero as necessary.  Scripts with a lower
      //  priority are executed before the ones with a higher priority.  Scripts
      //  without a priority are executed in parallel after all the scripts with
      //  a priority have completed.

      // We need to sort the scripts by the optional priority field
      let PriorityScripts = {};
      let OtherScripts = [];
      for (let script of Scripts) {
        let ScriptExtension = Path.extname(script);
        let ScriptDir = Path.dirname(script);
        let ScriptName = Path.basename(script, ScriptExtension);

        let ScriptPriority = (ScriptName.split(/\./))[1];
        if (ScriptPriority.match(/\d\d/)) {

          // If a script with this priority already exists, push this script
          //  lower in the queue.
          while (PriorityScripts[ScriptPriority]) {
            ScriptPriority++;
          }
          PriorityScripts[ScriptPriority] = {
            'FullPath': script,
            'ScriptName': ScriptName,
            'ScriptExtension': ScriptExtension,
            'ScriptDir': ScriptDir
          };
        }
        else {
          OtherScripts.push({
            'FullPath': script,
            'ScriptName': ScriptName,
            'ScriptExtension': ScriptExtension,
            'ScriptDir': ScriptDir
          });
        }
      }

      //TODO: Execute priority sorted scripts

      // All of the non-priority scripts are run in parallel
      let ScriptPromises = [];
      for (let index of OtherScripts) {
        ScriptPromises.push((function(script) {
          let ExecDeferred = Q.defer();

          exec('"' + script.FullPath + '"', function(error, stdout, stderr) {
            if (error) {
              ExecDeferred.reject(error);
              return false;
            }
            console.log(stdout);
            ExecDeferred.resolve([script, stdout]);
          });

          return ExecDeferred.promise;
        }).call(this, index));
      }

      Q.allSettled(ScriptPromises).then(function(items) {
        console.log("ScriptPromises Result: ", items);
        deferred.resolve();
      });
    })
    .fail(function(err) {
      console.log(err);
    })

    return deferred.promise;
  }
}

module.exports = new HookScripts();
