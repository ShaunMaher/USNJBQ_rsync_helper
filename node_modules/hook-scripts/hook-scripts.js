"use strict"
var Q = require('q');
var FileSystem = require('fs');
var Path = require('path');
const exec = require('child_process').exec;

function HookScripts() {
  if (!this) {
    return new HookScripts();
  }

  let ScriptName = require.main.filename;
  let ScriptExt = Path.extname(ScriptName);
  let ScriptDir = Path.dirname(ScriptName);
  ScriptName = Path.basename(ScriptName, ScriptExt);

  // Filesystem Root
  let FSRoot = Path.dirname(require.main.filename);
  while (Path.dirname(FSRoot) != FSRoot) {
    FSRoot = Path.dirname(FSRoot);
  }

  // This is a big list of places we should look for hook scripts if the calling
  //  app doesn't specify any.
  this.SearchPaths = [
    ScriptDir,
    Path.dirname(ScriptDir),
    Path.dirname(Path.dirname(ScriptDir)),
    ScriptDir + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "hooks",
    ScriptDir + Path.sep + "etc" + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "etc" + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "etc" + Path.sep + "hooks",
    FSRoot + Path.sep + "etc" + Path.sep + "hooks",
    ScriptDir + Path.sep + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    Path.dirname(ScriptDir) + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    Path.dirname(Path.dirname(ScriptDir)) + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
    FSRoot + Path.sep + "etc" + Path.sep + ScriptName + Path.sep + "hooks",
  ];

  this.RunScripts = function(EventName) {
    let deferred = Q.defer();
    let Scripts = [];

    var ReaddirPromises = [];
    for (var searchpath of this.SearchPaths) {
      ReaddirPromises.push((function(path) {
        let ReaddirDeferred = Q.defer();
        FileSystem.stat(path, function(err, stats) {
          if (err) {
            // The directory not existing isn't fatal.  There might be other
            //  directories that exist.
            ReaddirDeferred.resolve(false);
            return false;
          }

          FileSystem.readdir(path, function(err, files) {
            if (err) {
              console.log(path + ": " + err.message);
              ReaddirDeferred.reject(err);
              return false;
            }

            //EventName[.priority].Name
            for (let Script of files) {
              let ScriptEventName = (Script.split(/\./))[0];
              if (ScriptEventName.toLowerCase() == EventName.toLowerCase()) {
                Scripts.push(path + Path.sep + Script);
              }
            }
            ReaddirDeferred.resolve(true);
          });
        });
        return ReaddirDeferred.promise;
      }).call(this, searchpath));
    }

    Q.allSettled(ReaddirPromises).then(function(items) {
      console.log(EventName + " hooks: ", Scripts);
      deferred.resolve();
    })

    return deferred.promise;
  }
}

module.exports = new HookScripts();
